<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[不要笑我的笨]]></title>
  <subtitle><![CDATA[To be a better man.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-09-11T13:57:44.695Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Boom]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[20160911]]></title>
    <link href="http://yoursite.com/2016/09/11/20160911/"/>
    <id>http://yoursite.com/2016/09/11/20160911/</id>
    <published>2016-09-10T16:00:00.000Z</published>
    <updated>2016-09-11T13:57:44.695Z</updated>
    <content type="html"><![CDATA[<p>20160911<br><a id="more"></a><br>9月11号了，我坚持了4个月，你却一次也没有回头。<br>现在，想到你，还是会笑，会难过。<br>但我已经不会像之前那样，每天去搜你的qq号，微信号，哪怕只是一句，更新了相册，更新了说说。<br>微博还能默默看你的动态，所以我也决定戒了。<br>我知道，如果不这样做，我根本放不下，会一直放不下你。<br>尽管我已经想通了很多次，不管是外在，还是内在，我根本毫无胜算。<br>你又遇到了你很喜欢的人，他过着你想过的生活，有着你想拥有的美好品格。真是优秀啊。<br>抱歉，我现在还祝福不了你。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>20160911<br>]]>
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[23种设计模式]]></title>
    <link href="http://yoursite.com/2015/08/27/DesignPattern/"/>
    <id>http://yoursite.com/2015/08/27/DesignPattern/</id>
    <published>2015-08-27T09:02:07.000Z</published>
    <updated>2015-08-27T09:20:14.421Z</updated>
    <content type="html"><![CDATA[<p>本文学习了23种设计模式。<br><a id="more"></a></p>
<h1 id="1-_创建型">1. 创建型</h1><ol>
<li>Factory Method（工厂方法）<br><img src="http://www.ddupfly.com/assets/5/1.gif" alt=""><br>意图：<br>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。<br>适用性：<br>当一个类不知道它所必须创建的对象的类的时候。<br>当一个类希望由它的子类来指定它所创建的对象的时候。<br>当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li>
<li>Abstract Factory（抽象工厂）<br><img src="http://www.ddupfly.com/assets/5/2.gif" alt=""><br>意图：<br>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>适用性：<br>一个系统要独立于它的产品的创建、组合和表示时。<br>一个系统要由多个产品系列中的一个来配置时。<br>当你要强调一系列相关的产品对象的设计以便进行联合使用时。<br>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
<li>Builder（建造者）<br><img src="http://www.ddupfly.com/assets/5/3.gif" alt=""><br>意图：<br>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>适用性：<br>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。<br>当构造过程必须允许被构造的对象有不同的表示时。</li>
<li>Prototype（原型）<br><img src="http://www.ddupfly.com/assets/5/4.gif" alt=""><br>意图：<br>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>适用性：<br>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者<br>为了避免创建一个与产品类层次平行的工厂类层次时；或者<br>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
<li>Singleton（单例）<br><img src="http://www.ddupfly.com/assets/5/5.gif" alt=""><br>意图：<br>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>适用性：<br>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。<br>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
</ol>
<h1 id="2-_结构型">2. 结构型</h1><ol>
<li>Adapter Class/Object（适配器）<br><img src="http://www.ddupfly.com/assets/5/6.gif" alt=""><br>意图：<br>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>适用性：<br>你想使用一个已经存在的类，而它的接口不符合你的需求。<br>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。<br>（仅适用于对象Adapter ）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li>
<li>Bridge（桥接）<br><img src="http://www.ddupfly.com/assets/5/7.gif" alt=""><br>意图：<br>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>适用性：<br>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。<br>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。<br>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。<br>（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。<br>有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh 称这种类层次结构为“嵌套的普化”（nested generalizations ）。<br>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String 类[ Cop92 ]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。</li>
<li>Composite（组合）<br><img src="http://www.ddupfly.com/assets/5/8.gif" alt=""><br>意图：<br>将对象组合成树形结构以表示“部分-整体”的层次结构。C o m p o s i t e 使得用户对单个对象和组合对象的使用具有一致性。<br>适用性：<br>你想表示对象的部分-整体层次结构。<br>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
<li>Decorator（装饰）<br><img src="http://www.ddupfly.com/assets/5/9.gif" alt=""><br>意图：<br>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。<br>适用性：<br>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。<br>处理那些可以撤消的职责。<br>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li>
<li>Facade（外观）<br><img src="http://www.ddupfly.com/assets/5/10.gif" alt=""><br>意图：<br>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>适用性：<br>当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。<br>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。<br>当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。</li>
<li>Flyweight（享元）<br><img src="http://www.ddupfly.com/assets/5/11.gif" alt=""><br>意图：<br>运用共享技术有效地支持大量细粒度的对象。<br>适用性：<br>一个应用程序使用了大量的对象。<br>完全由于使用大量的对象，造成很大的存储开销。<br>对象的大多数状态都可变为外部状态。<br>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。<br>应用程序不依赖于对象标识。由于Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。</li>
<li>Proxy（代理）<br><img src="http://www.ddupfly.com/assets/5/12.gif" alt=""><br>意图：<br>为其他对象提供一种代理以控制对这个对象的访问。<br>适用性：<br>在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一 些可以使用Proxy 模式常见情况：<br>1) 远程代理（Remote Proxy ）为一个对象在不同的地址空间提供局部代表。 NEXTSTEP[Add94] 使用NXProxy 类实现了这一目的。Coplien[Cop92] 称这种代理为“大使” （Ambassador ）。<br>2 )虚代理（Virtual Proxy ）根据需要创建开销很大的对象。在动机一节描述的ImageProxy 就是这样一种代理的例子。<br>3) 保护代理（Protection Proxy ）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。例如，在Choices 操作系统[ CIRM93]中KemelProxies为操作系统对象提供 了访问保护。<br>4 )智能指引（Smart Reference ）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括：<br>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它(也称为SmartPointers[Ede92 ] )。<br>当第一次引用一个持久对象时，将它装入内存。<br>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li>
</ol>
<h1 id="3-_行为型">3. 行为型</h1><ol>
<li>Interpreter（解释器）<br><img src="http://www.ddupfly.com/assets/5/13.gif" alt=""><br>意图：<br>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>适用性：<br>当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：<br>该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。<br>效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。</li>
<li>Template Method（模板方法）<br><img src="http://www.ddupfly.com/assets/5/14.gif" alt=""><br>意图：<br>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>适用性：<br>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。<br>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke 和Johnson 所描述过的“重分解以一般化”的一个很好的例子[ OJ93 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。<br>控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。</li>
<li>Chain of Responsibility（责任链）<br><img src="http://www.ddupfly.com/assets/5/15.gif" alt=""><br>意图：<br>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br>适用性：<br>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。<br>你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。<br>可处理一个请求的对象集合应被动态指定。</li>
<li>Command（命令）<br><img src="http://www.ddupfly.com/assets/5/16.gif" alt=""><br>意图：<br>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。<br>适用性：<br>抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（call back）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command 模式是回调机制的一个面向对象的替代品。<br>在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。<br>支持取消操作。Command的Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command 接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。<br>支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。<br>用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( transaction)的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。</li>
<li>Iterator（迭代器）<br><img src="http://www.ddupfly.com/assets/5/17.gif" alt=""><br>意图：<br>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。<br>适用性：<br>访问一个聚合对象的内容而无需暴露它的内部表示。<br>支持对聚合对象的多种遍历。<br>为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。</li>
<li>Mediator（中介者）<br><img src="http://www.ddupfly.com/assets/5/18.gif" alt=""><br>意图：<br>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br>适用性：<br>一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。<br>一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。<br>想定制一个分布在多个类中的行为，而又不想生成太多的子类。</li>
<li>Memento（备忘录）<br><img src="http://www.ddupfly.com/assets/5/19.gif" alt=""><br>意图：<br>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<br>适用性：<br>必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。<br>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li>
<li>Observer（观察者）<br><img src="http://www.ddupfly.com/assets/5/20.gif" alt=""><br>意图：<br>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。<br>适用性：<br>当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。<br>当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。<br>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</li>
<li>State（状态）<br><img src="http://www.ddupfly.com/assets/5/21.gif" alt=""><br>意图：<br>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。<br>适用性：<br>一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。<br>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</li>
<li>Strategy（策略）<br><img src="http://www.ddupfly.com/assets/5/22.gif" alt=""><br>意图：<br>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。<br>适用性：<br>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。<br>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时[H087] ,可以使用策略模式。<br>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。<br>一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。</li>
<li>Visitor（访问者）<br><img src="http://www.ddupfly.com/assets/5/23.gif" alt=""><br>意图：<br>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>适用性：<br>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。<br>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[OJ93]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。<br>控制子类扩展。模板方法只在特定点调用“hook ”操作（参见效果一节），这样就只允许在这些点进行扩展。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了23种设计模式。<br>]]>
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（4）]]></title>
    <link href="http://yoursite.com/2015/08/27/JVM-4/"/>
    <id>http://yoursite.com/2015/08/27/JVM-4/</id>
    <published>2015-08-27T03:30:11.000Z</published>
    <updated>2016-09-11T13:59:06.810Z</updated>
    <content type="html"><![CDATA[<p>本文学习了虚拟机类加载机制。<br>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的。这是Java的可以动态扩展的语言特性。<br><a id="more"></a></p>
<h1 id="1-_类加载的时机">1. 类加载的时机</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载7个阶段。其中验证，准备，解析3个部分统称为连接。<br>加载，验证，准备，初始化和卸载这5个阶段的顺序是确定的，解析不一定，某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。<br>类加载的第一阶段，加载，交给虚拟机的具体实现来只有把握，但初始化阶段，规定了有且只有5种情况必须立即对类进行初始化：</p>
<ul>
<li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时。最常见的代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候。</li>
<li>当初始化一个类的时候，如果其父类还没有进行初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类）。</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化。<br>这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。<br>接口也有初始化过程，接口与类的区别在第三种，一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul>
<h1 id="2-_类加载的过程">2. 类加载的过程</h1><p>7阶段的前5阶段为类加载的全过程，加载，验证，准备，解析，初始化。</p>
<ol>
<li>加载<br>虚拟机需要完成以下3件事情：<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
</li>
<li>验证<br>验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。如果验证到输入的字节流不符合Class文件格式的约束，虚拟机抛出java.lang.VerifyError异常或其子类异常。<br>从整体上看，验证阶段大致会完成下面4个阶段的检索动作：文件格式验证、元数据验证、字节码验证、符号引用验证。<ul>
<li>文件格式验证<br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。主要目的是保证输入的字节流能正确地解析并存储于方法区之内。</li>
<li>元数据验证<br>对字节码描述的信息进行语义分析。主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</li>
<li>字节码验证<br>主要目的是通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事。</li>
<li>符号引用验证<br>可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。目的是确保解析动作能正常执行。</li>
</ul>
</li>
<li>准备<br>正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包含类变量（static变量），而不包括实例变量。</li>
<li>解析<br>虚拟机将常量池内的符号引用替换为直接引用的过程。</li>
<li>初始化<br>真正开始执行类中定义的Java程序代码（字节码）。执行初始化，是所有类变量的赋值动作和静态语句块，非构造函数。多线程下，能被正确的加锁，同步。只会有一个线程去初始化一个类，其余线程等待。</li>
</ol>
<h1 id="3-_类加载器">3. 类加载器</h1><p>通过一个类的全限定名来获取描述此类的二进制字节流，被类加载器实现。</p>
<ol>
<li><p>类与类加载器<br>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ClassLoaderTest &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws InstantiationException,</span><br><span class="line">            IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">		<span class="keyword">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				String className = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">				<span class="comment">//返回读取指定资源的输入流</span></span><br><span class="line">				InputStream <span class="keyword">is</span> = getClass().getResourceAsStream(className);</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">is</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">				<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">is</span>.available()];</span><br><span class="line">				<span class="keyword">is</span>.read(b);</span><br><span class="line">				<span class="comment">//将一个byte数组转换为Class类的实例</span></span><br><span class="line">				<span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	Object object = myLoader.loadClass(<span class="string">"test.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">	System.<span class="keyword">out</span>.println(object.getClass());</span><br><span class="line">	System.<span class="keyword">out</span>.println(object instanceof test.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------</span><br><span class="line"><span class="keyword">class</span> test.ClassLoaderTest</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双亲委派模型<br>从Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器，由C++实现，是虚拟机自身的一部分；另一种是所有其他的类加载器，由Java实现，独立于虚拟机外部，并全部继承java.lang.ClassLoader。<br>从开发人员角度来看，类加载器可以划分得更细致一些。</p>
<ul>
<li>启动类加载器：<code>&lt;JAVA_HOME&gt;\lib</code>目录下的类库。</li>
<li>扩展类加载器：<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下的类库。</li>
<li>应用程序类加载器：也称系统类加载器，加载用户类路径（ClassPath）上类库，默认的类加载器。</li>
</ul>
</li>
</ol>
<p><img src="http://www.ddupfly.com/assets/4/1.jpg" alt=""><br>  该类加载器之间的关系成为类加载器的双亲委派模型。要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的父子关系一般不会以继承，而是组合的方式来复用。双亲委派模型是在JDK1.2期间引入，并不是一个强制性约束模型。<br>  工作过程：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成。只有当父类加载器反馈自己无法完成（它搜索范围内没有找到所需的类）时，子加载器才会尝试去加载。<br>  显而易见的好处是，Java类随着它的类加载器一起具备了一种带有优先级的层次关系，例如java.lang.Object，Object在程序的各个类加载器环境中都是同一个类。这对Java程序的稳定运作十分重要。</p>
<ol>
<li>破坏双亲委派模型<br>主要出现过3次大规模的“被破坏”情况。<ul>
<li>JDK1.2发布之前，解决方法：JDK1.2之后，ClassLoader增加新的protected方法findClass()。</li>
<li>自身的缺陷，基础类想调用回用户的代码。解决方法：线程上下文类加载器。</li>
<li>对程序动态性的追求，例如代码热替换，模块热部署。解决方法：OSGi（Java模块化标准），它自定义了类加载机制，每一个程序模块Bundle都有一个自己的类加载器。OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂网状结构。</li>
</ul>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了虚拟机类加载机制。<br>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的。这是Java的可以动态扩展的语言特性。<br>]]>
    
    </summary>
    
      <category term="Java语言" scheme="http://yoursite.com/tags/Java%E8%AF%AD%E8%A8%80/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（3）]]></title>
    <link href="http://yoursite.com/2015/08/26/JVM-3/"/>
    <id>http://yoursite.com/2015/08/26/JVM-3/</id>
    <published>2015-08-26T07:34:45.000Z</published>
    <updated>2016-09-11T13:58:57.655Z</updated>
    <content type="html"><![CDATA[<p>本文学习了垃圾收集器与内存分配策略。<br><a id="more"></a></p>
<h1 id="1-_对象是否存活">1. 对象是否存活</h1><ol>
<li><p>引用计数算法<br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>客观地讲，引用计数算法的实现简单，判断效率也很高，例如微软的COM技术，Python语言等都使用了引用计数算法进行内存管理。<br>但是缺点是它很难解决对象之间相互循环引用的问题。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">MyObject</span> &#123;</span><br><span class="line">    public <span class="type">Object</span> <span class="keyword">ref</span> = null;</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">MyObject</span> myObject1 = new <span class="type">MyObject</span>();</span><br><span class="line">        <span class="type">MyObject</span> myObject2 = new <span class="type">MyObject</span>();</span><br><span class="line">        myObject1.<span class="keyword">ref</span> = myObject2;</span><br><span class="line">        myObject2.<span class="keyword">ref</span> = myObject1;</span><br><span class="line">        myObject1 = null;</span><br><span class="line">        myObject2 = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是具体是为什么呢？当代码执行完line7时，两个对象的引用计数均为2。此时将myObject1和myObject2分别置为null，以前一个对象为例，它的引用计数将减1。若要满足垃圾回收的条件，需要清除myObject2中的ref这个引用，而要清除掉这个引用的前提条件是myObject2引用的对象被回收，可是该对象的引用计数也为1，因为myObject1.ref指向了它。以此类推，也就进入一种死循环的状态。</p>
</li>
<li>可达性分析算法<br>主流的商用程序语言（Java，C#等）的主流实现中，都是称通过可达性分析来判定对象是否存活的。<br>基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明该对象不可用。<br>在Java语言中，可作为GC Roots的对象包括下面几种：<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常用引用的对象。</li>
<li>本地方法栈中JNI（Native方法）引用的对象。</li>
</ul>
</li>
<li>四种引用类型<br>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用。强度依次逐渐减弱。<ul>
<li>强引用<br>是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用<br>是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li>
<li>弱引用<br>也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用<br>是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ul>
</li>
<li><p>生存还是死亡<br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这2种情况都视为“没有必要执行”。<br>如果对象被判定有必要执行finalize()方法，那么这个对象将会放置到一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里的“执行”是指虚拟机会触发方法，但并不承诺等待它运行结束。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果这时对象重新与引用链上的任何一对象建立关联，那么对象将存活下来；否则，对象基本上就真的被回收了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 1.对象可以在被GC时自我拯救</span><br><span class="line"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscape FC = <span class="keyword">null</span>;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>&#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"finalize method invoke"</span>);</span><br><span class="line">        FC = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception </span>&#123;</span><br><span class="line">        FC = <span class="keyword">new</span> FinalizeEscape();</span><br><span class="line">        FC = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(FC != <span class="keyword">null</span>)</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am alive"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am dead"</span>);</span><br><span class="line">        FC = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(FC != <span class="keyword">null</span>)</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am alive"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line">finalize method invoke </span><br><span class="line">i am alive </span><br><span class="line">i am dead</span><br></pre></td></tr></table></figure>
<p> 建议尽量避免使用finalize()，它运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</p>
</li>
<li><p>回收方法区<br>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。但判定一个类是否是“无用的类”的条件相对苛刻许多。<br>类需要同时满足下面3个条件才能算是“无用的类”。</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机<strong>可以</strong>对满足上述3个条件的无用类进行回收。<br>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
</li>
</ol>
<h1 id="2-_垃圾收集算法">2. 垃圾收集算法</h1><ol>
<li>标记-清除算法<br>Mark-Sweep算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br><img src="http://www.ddupfly.com/assets/3/1.jpg" alt=""><br>主要不足：一个是效率问题，两个过程都不高；二是空间问题，标记清除之后，将产生大量不连续的内存碎片，将来分配大内存，无连续空间的时候，不得不提前触发一次垃圾收集动作。</li>
<li>复制算法<br>Copying算法，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存，实现简单，运行高效。只是缩小一半内存，算法的代价有点高了。<br><img src="http://www.ddupfly.com/assets/3/2.jpg" alt=""><br>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li>
<li>标记-整理算法<br>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br><img src="http://www.ddupfly.com/assets/3/3.jpg" alt=""></li>
<li>分代收集算法<br>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</li>
</ol>
<h1 id="3-_垃圾收集器">3. 垃圾收集器</h1><p>JDK1.7之后的HotSpot虚拟机包含的所有收集器如图，存在连线说明可以搭配使用。<br><img src="http://www.ddupfly.com/assets/3/4.jpg" alt=""></p>
<ol>
<li>Serial收集器<br>一个单线程的收集器，它不仅仅是只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情称之为“Stop The World”），直到它收集结束。“Stop The World”实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户的正常工作的线程全部停掉。<br><img src="http://www.ddupfly.com/assets/3/5.jpg" alt=""><br>Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。</li>
<li>ParNew收集器<br>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。<br><img src="http://www.ddupfly.com/assets/3/6.jpg" alt=""><br>ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。<br>在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器（Concurrent Mark Sweep），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。不幸的是，它作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器也是使用 -XX: +UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC选项来强制指定它。<br>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。<br>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。</li>
<li>Parallel Scavenge收集器<br>Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，也是并行的多线程收集器。<br>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。<br>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。<br>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。<br>MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。<br>GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。<br>由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。如果读者对于收集器运作原理不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个很不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio参数（更关注吞吐量）给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</li>
<li>Serial Old收集器<br>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。<br>这个收集器的主要意义也是被Client模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途：一个是在JDK 1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</li>
<li>Parallel Old收集器<br>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供的。在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的“拖累”，即便使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。<br>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。<br><img src="http://www.ddupfly.com/assets/3/7.jpg" alt=""></li>
<li><p>CMS收集器<br>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。<br>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。<br><img src="http://www.ddupfly.com/assets/3/8.jpg" alt=""><br>CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/ 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，这也很让人受不了。为了解决这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep / i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。</li>
<li>还有最后一个缺点，CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX: CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。</li>
</ul>
</li>
<li><p>G1收集器<br>G1是一款面对服务端应用的垃圾收集器。在（比较长期的）未来可以替换掉JDK1.5中发布的CMS收集器。G1具备以下特点：</p>
<ul>
<li>并行与并发：使用多个CPU（CPU或CPU核心）来缩短StopTheWorld停顿的时间，可通过并发方式让Java程序继续执行。</li>
<li>分代收集：可以不需要其他收集器配合，采用不同的方式分代收集。</li>
<li>空间整合：从整体上看是基于“标记-清理”算法实现，从局部（两个Region）看是基于复制算法实现。</li>
<li>可预测的停顿：除了降低停顿外，还建立了可预测的停顿时间模型，能让使用者明确指定在M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
<p>使用G1收集器时，Java堆划分为多个大小相等的独立区域（Region），新生代和老年代不再是物理隔离的，它们都是一部分Region（不需要连续）的集合。<br>G1有计划的避免在整个Java堆进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的时间，优先回收价值最大的Region。<br>G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个对应的Remembered Set，虚拟机发现程序对Reference类型数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。在进行内存回收时，GC Roots的枚举范围加Remembered Set即可保证不对全堆扫描也不会有遗漏。<br>G1收集器运作大致分为：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。最后筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。<br><img src="http://www.ddupfly.com/assets/3/9.png" alt=""></p>
</li>
<li>垃圾收集器参数总结<br><img src="http://www.ddupfly.com/assets/3/10.jpg" alt=""></li>
</ol>
<h1 id="4-_内存分配与回收策略">4. 内存分配与回收策略</h1><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。<br>对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<ol>
<li>对象优先在Eden分配<br>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。<br>虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析。<br>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。<br>老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。MajorGC的速度一般会比Minor GC慢10倍以上。</li>
<li>大对象直接进入老年代<br>所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。<br>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。<br>PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</li>
<li>长期存活的对象将进入老年代<br>虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。</li>
<li>动态对象年龄判定<br>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li>
<li>空间分配担保<br>在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。<br>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时（最极端就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。<br>取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了垃圾收集器与内存分配策略。<br>]]>
    
    </summary>
    
      <category term="Java语言" scheme="http://yoursite.com/tags/Java%E8%AF%AD%E8%A8%80/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（2）]]></title>
    <link href="http://yoursite.com/2015/08/25/JVM-2/"/>
    <id>http://yoursite.com/2015/08/25/JVM-2/</id>
    <published>2015-08-25T02:15:34.000Z</published>
    <updated>2016-09-11T13:58:51.606Z</updated>
    <content type="html"><![CDATA[<p>本文学习了Java的内存区域、HotSpot虚拟机对象探秘和<code>OutOfMemoryError</code>异常。<br><a id="more"></a></p>
<h1 id="1-_运行时数据区域">1. 运行时数据区域</h1><p><img src="http://www.ddupfly.com/assets/2/1.jpg" alt=""></p>
<ol>
<li>程序计数器<br>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<br>由于Java虚拟机的多线程是通过线程切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对多核处理器是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，这类区域称为“线程私有”的内存。<br>如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法，计数器值为空（Undefined）。<br>此内存是唯一一个<strong>没有</strong>规定任何<code>OutOfMemoryError</code>情况的区域。</li>
<li>Java虚拟机栈<br>线程私有，生命周期与线程相同。<br>描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，为入栈到出栈的过程。<br>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象应用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。long和double占用2个，其余基本数据类型为1个局部变量空间。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变。<br>线程请求的栈深度大于虚拟机所允许的深度，抛出<code>StackOverflowError</code>异常；如果虚拟机动态扩展时无法申请到足够内存，抛出<code>OutOfMemoryError</code>异常。</li>
<li>本地方法栈<br>与虚拟机栈类似，区别为其为Native方法服务。<br>具体的虚拟机可以自由实现它，甚至Sun HotSpot虚拟机将其和虚拟机栈合二为一。<br>异常抛出同上。</li>
<li>Java堆<br>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。被所有线程共享，在虚拟机启动时创建，唯一目的就是存放对象实例，以及数组。<br>Java堆是垃圾收集器管理的主要区域，也可称为GC堆。从内存回收角度看，基于分代收集算法，Java堆细分为新生代和老年代，新生代包括Eden空间，From Survivor空间，To Survivor空间等。从内存分配角度看，线程共享的Java堆可能划分多个线程私有的分配缓冲区（TLAB）。<br>Java可以处于物理上不连续的内存空间，只要逻辑上是连续的即可，当前主流虚拟机可动态扩展（通过-Xmx和-Xms控制）。如果堆中内存不足，并且堆无法扩展，抛出<code>OutOfMemoryError</code>异常。</li>
<li>方法区<br>各个线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区为堆的一个逻辑部分，但称为Non-Heap（非堆），目的是与Java堆区分。<br>对于HotSpot，可把方法区分为永久代（Permanent Generation），因为GC分代收集扩展到方法区。但这样更容易遇到内存溢出问题，官方也有放弃永久代改用Native Memory来实现方法区的规划。在JDK1.7中，已经把原本放在永久代的字符串常量池移出至堆中。对此区域未完全回收将导致内存泄露。<br>当方法区无法满足内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</li>
<li>运行时常量池<br>它是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池。<br>运行时常量池具备动态性，在运行期间也可能将新的常量放入此中，例如String的intern()方法。<br>当常量池无法再申请到内存时抛出<code>OutOfMemoryError</code>异常。</li>
<li>直接内存<br>并不是虚拟机运行时数据区的一部分。在各个内存区域总和加上直接内存大于物理内存的限制，也可能抛出<code>OutOfMemoryError</code>异常。</li>
</ol>
<h1 id="2-_HotSpot虚拟机对象">2. HotSpot虚拟机对象</h1><ol>
<li>对象的创建<br>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先执行相应的类加载过程。<br>在类加载检查通过后，虚拟机为新生对象从Java堆中分配内存。对象所需内存的大小在类加载完成后便完全确定。<br>假设Java堆中内存是绝对规整的，所有用过的内存放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那分配内存就是挪动指针。这种分配方式称为<strong>“指针碰撞”</strong>。<br>假设Java堆中内存不是规整的，用过的与空闲的相互交错，虚拟机必须维护一个列表，记录哪些内存块可用。这种分配方式称为<strong>“空闲列表”</strong>。<br>选择哪种分配方式由Java堆是否规整决定，它由所采用的垃圾收集器是否带有压缩整理功能决定。在使用Serial、ParNew等带Compact过程的收集器是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器，采用空闲列表。并发情况下，这些过程并不是线程安全的。<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。<br>接下来，虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些存放在对象的对象头之中。<br>至此，以虚拟机的角度看，一个新的对象已经产生，但从Java程序的角度看，对象创建才刚刚开始，还须init初始化操作。</li>
<li>对象的内存布局<br>对象在内存的布局分为3块：对象头，实例数据和对齐填充。<br>对象头包括两部分信息，一是用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，成为Mark Word。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定是哪个类的实例。如果对象是Java数组，对象头中还须记录数组长度。<br>接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。<br>第三部分是对齐填充，起占位符的作用，HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。对象头正好为8字节的1倍或2倍。</li>
<li>对象的访问定位<br>栈上的reference数据来操作堆上的具体对象，对象的访问方式，取决于虚拟机实现。主流有2种。<br>如果用句柄访问。<br><img src="http://www.ddupfly.com/assets/2/2.jpg" alt=""><br>如果使用字节指针访问<br><img src="http://www.ddupfly.com/assets/2/3.jpg" alt=""><br>各有优势，使用句柄最大好处是reference中存储的是稳定的句柄地址，在对象被移动时（垃圾收集移动对象）只会改变句柄中的实例数据指针，而reference本身不用改变。使用直接指针最大好处是速度更快，节省了一次指针定位的时间开销。Sun HotSpot采用第二种进行对象访问。</li>
</ol>
<h1 id="3-_OutOfMemoryError异常">3. <code>OutOfMemoryError</code>异常</h1><ol>
<li>Java堆溢出<br>只要不断地创建对象，并且GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。<br>最小值参数-Xms，最大值参数-Xmx，设置为相等时可以避免自动扩展。<br>-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。<br>异常信息为：<code>java.lang.OutOfMemoryError: Java heap space</code>。<br>解决方法：如果是内存泄露，可以查看泄露对象到GC Roots的引用链，准确定位出泄露代码的位置。如果不存在泄露，应检查虚拟机堆参数大小是否可以调整，二是从代码上尝试减少程序运行期的内存消耗。</li>
<li>虚拟机栈和本地方法栈溢出<br>栈容量由-Xss参数设定。<br>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时，都是抛出<code>StackOverflowError</code>异常。多线程下，为每个线程的栈分配的内存越大，越容易产生内存溢出，抛出<code>OutOfMemoryError</code>异常。所以在不能减少线程数或更换64位虚拟机的情况下，应“减少内存”的手段解决。</li>
<li>方法区和运行时常量区溢出<br>JDK1.6及以前，由于常量池分配在永久代内，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小。<br>异常信息为：<code>java.lang.OutOfMemoryError: PermGen space</code>。<br>而JDK1.7后不会有这个结果。<br>方法区溢出也很常见，一个类要被垃圾收集器回收掉，绑定条件是比较苛刻的。例如大量JSP或动态产生JSP文件的应用，基于OSGi的应用，使用CGLib字节码增强和动态语言等。</li>
<li>本机直接内存溢出<br>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值一样。<br>OOM之后Dump文件很小，程序又直接或间接使用NIO，可能是本机直接内存溢出。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了Java的内存区域、HotSpot虚拟机对象探秘和<code>OutOfMemoryError</code>异常。<br>]]>
    
    </summary>
    
      <category term="Java语言" scheme="http://yoursite.com/tags/Java%E8%AF%AD%E8%A8%80/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（1）]]></title>
    <link href="http://yoursite.com/2015/08/24/JVM-1/"/>
    <id>http://yoursite.com/2015/08/24/JVM-1/</id>
    <published>2015-08-24T08:27:00.000Z</published>
    <updated>2016-09-11T13:58:40.956Z</updated>
    <content type="html"><![CDATA[<p>本文学习了Java的技术体系和对Java技术的未来进行展望。<br><a id="more"></a></p>
<h1 id="1-_Java技术体系">1. Java技术体系</h1><ul>
<li>Sun官方定义的Java技术体系包括：Java程序设计语言，各种硬件平台上的Java虚拟机，Class文件格式，Java API类库，第三方Java类库。<br><img src="http://www.ddupfly.com/assets/1/1.jpg" alt=""></li>
<li>可以把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK(Java Development Kit)，是用于支持Java程序开发的最小环境。</li>
<li>可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE(Java Runtime Environment)，是支持Java程序运行的标准环境。</li>
</ul>
<h1 id="2-_展望Java技术的未来">2. 展望Java技术的未来</h1><ol>
<li>模块化<br>解决应用系统与技术平台越来越复杂、越来越庞大问题的重要途径。</li>
<li>混合语言<br>运行在一个虚拟机之上。通过特定领域的语言去解决特定领域的问题。</li>
<li>多核并行<br>如今，CPU硬件的发展方向已经从高频率转变为多核心。JDK1.5就引入了<code>java.util.concurrent</code>包实现了一个粗粒度的并发框架。JDK1.7加入的<code>java.util.concurrent.forkjoin</code>则是重要扩充。</li>
<li>进一步丰富语法<br>Java 5曾经对java语法了进行一次扩充，加入了自动装箱，泛型，动态注解，枚举，可变长参数，遍历循环等语法，使Java语言的精确性和易用性有了很大的进步。</li>
<li>64位虚拟机<br>虽然Java程序运行在64位虚拟机上需要付出比较大的额外代价（消耗更多的内存，运行速度落后），但企业级应用经常需要使用超过4GB内存，对64位虚拟机需求非常迫切。随着硬件的进一步发展，计算机终究会完全过渡到64位的时代，虚拟机对其的支持也应进一步完善。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了Java的技术体系和对Java技术的未来进行展望。<br>]]>
    
    </summary>
    
      <category term="Java语言" scheme="http://yoursite.com/tags/Java%E8%AF%AD%E8%A8%80/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
</feed>
