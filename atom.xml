<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[不要笑我的笨]]></title>
  <subtitle><![CDATA[梦想是一定要有的.. 万一实现了呢..]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-08-26T03:50:54.276Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Boom]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（3）]]></title>
    <link href="http://yoursite.com/2015/08/25/JVM-3/"/>
    <id>http://yoursite.com/2015/08/25/JVM-3/</id>
    <published>2015-08-25T06:42:20.000Z</published>
    <updated>2015-08-26T03:50:54.276Z</updated>
    <content type="html"><![CDATA[<p>本文学习了垃圾收集器与内存分配策略。<br><a id="more"></a></p>
<h1 id="1-_对象是否存活">1. 对象是否存活</h1><ol>
<li><p>引用计数算法<br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>客观地讲，引用计数算法的实现简单，判断效率也很高，例如微软的COM技术，Python语言等都使用了引用计数算法进行内存管理。<br>但是缺点是它很难解决对象之间相互循环引用的问题。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">MyObject</span> &#123;</span><br><span class="line">    public <span class="type">Object</span> <span class="keyword">ref</span> = null;</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">MyObject</span> myObject1 = new <span class="type">MyObject</span>();</span><br><span class="line">        <span class="type">MyObject</span> myObject2 = new <span class="type">MyObject</span>();</span><br><span class="line">        myObject1.<span class="keyword">ref</span> = myObject2;</span><br><span class="line">        myObject2.<span class="keyword">ref</span> = myObject1;</span><br><span class="line">        myObject1 = null;</span><br><span class="line">        myObject2 = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是具体是为什么呢？当代码执行完line7时，两个对象的引用计数均为2。此时将myObject1和myObject2分别置为null，以前一个对象为例，它的引用计数将减1。若要满足垃圾回收的条件，需要清除myObject2中的ref这个引用，而要清除掉这个引用的前提条件是myObject2引用的对象被回收，可是该对象的引用计数也为1，因为myObject1.ref指向了它。以此类推，也就进入一种死循环的状态。</p>
</li>
<li>可达性分析算法<br>主流的商用程序语言（Java，C#等）的主流实现中，都是称通过可达性分析来判定对象是否存活的。<br>基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明该对象不可用。<br>在Java语言中，可作为GC Roots的对象包括下面几种：<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常用引用的对象。</li>
<li>本地方法栈中JNI（Native方法）引用的对象。</li>
</ul>
</li>
<li>四种引用类型<br>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用。强度依次逐渐减弱。<ul>
<li>强引用<br>是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用<br>是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li>
<li>弱引用<br>也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用<br>是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ul>
</li>
<li><p>生存还是死亡<br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这2种情况都视为“没有必要执行”。<br>如果对象被判定有必要执行finalize()方法，那么这个对象将会放置到一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里的“执行”是指虚拟机会触发方法，但并不承诺等待它运行结束。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果这时对象重新与引用链上的任何一对象建立关联，那么对象将存活下来；否则，对象基本上就真的被回收了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 1.对象可以在被GC时自我拯救</span><br><span class="line"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscape FC = <span class="keyword">null</span>;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>&#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"finalize method invoke"</span>);</span><br><span class="line">        FC = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception </span>&#123;</span><br><span class="line">        FC = <span class="keyword">new</span> FinalizeEscape();</span><br><span class="line">        FC = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(FC != <span class="keyword">null</span>)</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am alive"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am dead"</span>);</span><br><span class="line">        FC = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(FC != <span class="keyword">null</span>)</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am alive"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line">finalize method invoke </span><br><span class="line">i am alive </span><br><span class="line">i am dead</span><br></pre></td></tr></table></figure>
<p> 建议尽量避免使用finalize()，它运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</p>
</li>
<li>回收方法区<br>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。但判定一个类是否是“无用的类”的条件相对苛刻许多。<br>类需要同时满足下面3个条件才能算是“无用的类”。<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。<br>虚拟机<strong>可以</strong>对满足上述3个条件的无用类进行回收。<br>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</li>
</ul>
</li>
</ol>
<h1 id="2-_垃圾收集算法">2. 垃圾收集算法</h1><ol>
<li>标记-清除算法<br>Mark-Sweep算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br><img src="http://www.ddupfly.com/assets/3/1.jpg" alt=""><br>主要不足：一个是效率问题，两个过程都不高；二是空间问题，标记清除之后，将产生大量不连续的内存碎片，将来分配大内存，无连续空间的时候，不得不提前触发一次垃圾收集动作。</li>
<li>复制算法<br>Copying算法，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存，实现简单，运行高效。只是缩小一半内存，算法的代价有点高了。<br><img src="http://www.ddupfly.com/assets/3/2.jpg" alt=""><br>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li>
<li>标记-整理算法<br>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br><img src="http://www.ddupfly.com/assets/3/3.jpg" alt=""></li>
<li>分代收集算法<br>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</li>
</ol>
<h1 id="3-_垃圾收集器">3. 垃圾收集器</h1><p>JDK1.7之后的HotSpot虚拟机包含的所有收集器如图，存在连线说明可以搭配使用。<br><img src="http://www.ddupfly.com/assets/3/4.jpg" alt=""></p>
<ol>
<li>Serial收集器<br>一个单线程的收集器，它不仅仅是只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情称之为“Stop The World”），直到它收集结束。“Stop The World”实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户的正常工作的线程全部停掉。<br><img src="http://www.ddupfly.com/assets/3/5.jpg" alt=""><br>Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。</li>
<li>ParNew收集器<br>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、 -XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。<br><img src="http://www.ddupfly.com/assets/3/6.jpg" alt=""><br>ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。<br>在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可称为有划时代意义的垃圾收集器—CMS收集器（Concurrent Mark Sweep），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。不幸的是，它作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器也是使用 -XX: +UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用 -XX:+UseParNewGC选项来强制指定它。<br>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。<br>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续运行，而垃圾收集程序运行于另一个CPU上。</li>
<li>Parallel Scavenge收集器<br>Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，也是并行的多线程收集器。<br>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。<br>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。<br>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。<br>MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。<br>GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。<br>由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。如果读者对于收集器运作原理不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个很不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio参数（更关注吞吐量）给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</li>
<li>Serial Old收集器<br>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。<br>这个收集器的主要意义也是被Client模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途：一个是在JDK 1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</li>
<li>Parallel Old收集器<br>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供的。在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的“拖累”，即便使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。<br>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。<br><img src="http://www.ddupfly.com/assets/3/7.jpg" alt=""></li>
<li>CMS收集器<br>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</li>
</ol>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）<br>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。<br>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。<br><img src="http://www.ddupfly.com/assets/3/8.jpg" alt=""><br>CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是CMS还远达不到完美的程度，它有以下三个显著的缺点：<br>CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/ 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程最多占用不超过25%的CPU资源。但是当CPU不足4个时（譬如2个），那么CMS对用户程序的影响就可能变得很大，如果CPU负载本来就比较大的时候，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，这也很让人受不了。为了解决这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep / i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，速度下降也就没有那么明显，但是目前版本中，i-CMS已经被声明为“deprecated”，即不再提倡用户使用。<br>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序的运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好留待下一次GC时再将其清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即还需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数以获取更好的性能。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高将会很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。<br>还有最后一个缺点，在本节在开头说过，CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会产生大量空间碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX: CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了垃圾收集器与内存分配策略。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（2）]]></title>
    <link href="http://yoursite.com/2015/08/25/JVM-2/"/>
    <id>http://yoursite.com/2015/08/25/JVM-2/</id>
    <published>2015-08-25T02:15:34.000Z</published>
    <updated>2015-08-25T09:13:28.166Z</updated>
    <content type="html"><![CDATA[<p>本文学习了Java的内存区域、HotSpot虚拟机对象探秘和<code>OutOfMemoryError</code>异常。<br><a id="more"></a></p>
<h1 id="1-_运行时数据区域">1. 运行时数据区域</h1><p><img src="http://www.ddupfly.com/assets/2/1.jpg" alt=""></p>
<ol>
<li>程序计数器<br>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<br>由于Java虚拟机的多线程是通过线程切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对多核处理器是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，这类区域称为“线程私有”的内存。<br>如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法，计数器值为空（Undefined）。<br>此内存是唯一一个<strong>没有</strong>规定任何<code>OutOfMemoryError</code>情况的区域。</li>
<li>Java虚拟机栈<br>线程私有，生命周期与线程相同。<br>描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，为入栈到出栈的过程。<br>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象应用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。long和double占用2个，其余基本数据类型为1个局部变量空间。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变。<br>线程请求的栈深度大于虚拟机所允许的深度，抛出<code>StackOverflowError</code>异常；如果虚拟机动态扩展时无法申请到足够内存，抛出<code>OutOfMemoryError</code>异常。</li>
<li>本地方法栈<br>与虚拟机栈类似，区别为其为Native方法服务。<br>具体的虚拟机可以自由实现它，甚至Sun HotSpot虚拟机将其和虚拟机栈合二为一。<br>异常抛出同上。</li>
<li>Java堆<br>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。被所有线程共享，在虚拟机启动时创建，唯一目的就是存放对象实例，以及数组。<br>Java堆是垃圾收集器管理的主要区域，也可称为GC堆。从内存回收角度看，基于分代收集算法，Java堆细分为新生代和老年代，新生代包括Eden空间，From Survivor空间，To Survivor空间等。从内存分配角度看，线程共享的Java堆可能划分多个线程私有的分配缓冲区（TLAB）。<br>Java可以处于物理上不连续的内存空间，只要逻辑上是连续的即可，当前主流虚拟机可动态扩展（通过-Xmx和-Xms控制）。如果堆中内存不足，并且堆无法扩展，抛出<code>OutOfMemoryError</code>异常。</li>
<li>方法区<br>各个线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区为堆的一个逻辑部分，但称为Non-Heap（非堆），目的是与Java堆区分。<br>对于HotSpot，可把方法区分为永久代（Permanent Generation），因为GC分代收集扩展到方法区。但这样更容易遇到内存溢出问题，官方也有放弃永久代改用Native Memory来实现方法区的规划。在JDK1.7中，已经把原本放在永久代的字符串常量池移出至堆中。对此区域未完全回收将导致内存泄露。<br>当方法区无法满足内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</li>
<li>运行时常量池<br>它是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池。<br>运行时常量池具备动态性，在运行期间也可能将新的常量放入此中，例如String的intern()方法。<br>当常量池无法再申请到内存时抛出<code>OutOfMemoryError</code>异常。</li>
<li>直接内存<br>并不是虚拟机运行时数据区的一部分。在各个内存区域总和加上直接内存大于物理内存的限制，也可能抛出<code>OutOfMemoryError</code>异常。</li>
</ol>
<h1 id="2-_HotSpot虚拟机对象">2. HotSpot虚拟机对象</h1><ol>
<li>对象的创建<br>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先执行相应的类加载过程。<br>在类加载检查通过后，虚拟机为新生对象从Java堆中分配内存。对象所需内存的大小在类加载完成后便完全确定。<br>假设Java堆中内存是绝对规整的，所有用过的内存放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那分配内存就是挪动指针。这种分配方式称为<strong>“指针碰撞”</strong>。<br>假设Java堆中内存不是规整的，用过的与空闲的相互交错，虚拟机必须维护一个列表，记录哪些内存块可用。这种分配方式称为<strong>“空闲列表”</strong>。<br>选择哪种分配方式由Java堆是否规整决定，它由所采用的垃圾收集器是否带有压缩整理功能决定。在使用Serial、ParNew等带Compact过程的收集器是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器，采用空闲列表。并发情况下，这些过程并不是线程安全的。<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。<br>接下来，虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些存放在对象的对象头之中。<br>至此，以虚拟机的角度看，一个新的对象已经产生，但从Java程序的角度看，对象创建才刚刚开始，还须init初始化操作。</li>
<li>对象的内存布局<br>对象在内存的布局分为3块：对象头，实例数据和对齐填充。<br>对象头包括两部分信息，一是用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，成为Mark Word。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定是哪个类的实例。如果对象是Java数组，对象头中还须记录数组长度。<br>接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。<br>第三部分是对齐填充，起占位符的作用，HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。对象头正好为8字节的1倍或2倍。</li>
<li>对象的访问定位<br>栈上的reference数据来操作堆上的具体对象，对象的访问方式，取决于虚拟机实现。主流有2种。<br>如果用句柄访问。<br><img src="http://www.ddupfly.com/assets/2/2.jpg" alt=""><br>如果使用字节指针访问<br><img src="http://www.ddupfly.com/assets/2/3.jpg" alt=""><br>各有优势，使用句柄最大好处是reference中存储的是稳定的句柄地址，在对象被移动时（垃圾收集移动对象）只会改变句柄中的实例数据指针，而reference本身不用改变。使用直接指针最大好处是速度更快，节省了一次指针定位的时间开销。Sun HotSpot采用第二种进行对象访问。</li>
</ol>
<h1 id="3-_OutOfMemoryError异常">3. <code>OutOfMemoryError</code>异常</h1><ol>
<li>Java堆溢出<br>只要不断地创建对象，并且GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。<br>最小值参数-Xms，最大值参数-Xmx，设置为相等时可以避免自动扩展。<br>-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。<br>异常信息为：<code>java.lang.OutOfMemoryError: Java heap space</code>。<br>解决方法：如果是内存泄露，可以查看泄露对象到GC Roots的引用链，准确定位出泄露代码的位置。如果不存在泄露，应检查虚拟机堆参数大小是否可以调整，二是从代码上尝试减少程序运行期的内存消耗。</li>
<li>虚拟机栈和本地方法栈溢出<br>栈容量由-Xss参数设定。<br>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时，都是抛出<code>StackOverflowError</code>异常。多线程下，为每个线程的栈分配的内存越大，越容易产生内存溢出，抛出<code>OutOfMemoryError</code>异常。所以在不能减少线程数或更换64位虚拟机的情况下，应“减少内存”的手段解决。</li>
<li>方法区和运行时常量区溢出<br>JDK1.6及以前，由于常量池分配在永久代内，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小。<br>异常信息为：<code>java.lang.OutOfMemoryError: PermGen space</code>。<br>而JDK1.7后不会有这个结果。<br>方法区溢出也很常见，一个类要被垃圾收集器回收掉，绑定条件是比较苛刻的。例如大量JSP或动态产生JSP文件的应用，基于OSGi的应用，使用CGLib字节码增强和动态语言等。</li>
<li>本机直接内存溢出<br>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值一样。<br>OOM之后Dump文件很小，程序又直接或间接使用NIO，可能是本机直接内存溢出。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了Java的内存区域、HotSpot虚拟机对象探秘和<code>OutOfMemoryError</code>异常。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（1）]]></title>
    <link href="http://yoursite.com/2015/08/24/JVM-1/"/>
    <id>http://yoursite.com/2015/08/24/JVM-1/</id>
    <published>2015-08-24T08:27:00.000Z</published>
    <updated>2015-08-25T09:14:20.916Z</updated>
    <content type="html"><![CDATA[<p>本文学习了Java的技术体系和对Java技术的未来进行展望。<br><a id="more"></a></p>
<h1 id="1-_Java技术体系">1. Java技术体系</h1><ul>
<li>Sun官方定义的Java技术体系包括：Java程序设计语言，各种硬件平台上的Java虚拟机，Class文件格式，Java API类库，第三方Java类库。<br><img src="http://www.ddupfly.com/assets/1/1.jpg" alt=""></li>
<li>可以把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK(Java Development Kit)，是用于支持Java程序开发的最小环境。</li>
<li>可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE(Java Runtime Environment)，是支持Java程序运行的标准环境。</li>
</ul>
<h1 id="2-_展望Java技术的未来">2. 展望Java技术的未来</h1><ol>
<li>模块化<br>解决应用系统与技术平台越来越复杂、越来越庞大问题的重要途径。</li>
<li>混合语言<br>运行在一个虚拟机之上。通过特定领域的语言去解决特定领域的问题。</li>
<li>多核并行<br>如今，CPU硬件的发展方向已经从高频率转变为多核心。JDK1.5就引入了<code>java.util.concurrent</code>包实现了一个粗粒度的并发框架。JDK1.7加入的<code>java.util.concurrent.forkjoin</code>则是重要扩充。</li>
<li>进一步丰富语法<br>Java 5曾经对java语法了进行一次扩充，加入了自动装箱，泛型，动态注解，枚举，可变长参数，遍历循环等语法，使Java语言的精确性和易用性有了很大的进步。</li>
<li>64位虚拟机<br>虽然Java程序运行在64位虚拟机上需要付出比较大的额外代价（消耗更多的内存，运行速度落后），但企业级应用经常需要使用超过4GB内存，对64位虚拟机需求非常迫切。随着硬件的进一步发展，计算机终究会完全过渡到64位的时代，虚拟机对其的支持也应进一步完善。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了Java的技术体系和对Java技术的未来进行展望。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
</feed>
