<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[不要笑我的笨]]></title>
  <subtitle><![CDATA[梦想是一定要有的.. 万一实现了呢..]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-08-25T06:39:04.736Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Boom]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（2）]]></title>
    <link href="http://yoursite.com/2015/08/25/JVM-2/"/>
    <id>http://yoursite.com/2015/08/25/JVM-2/</id>
    <published>2015-08-25T02:15:34.000Z</published>
    <updated>2015-08-25T06:39:04.736Z</updated>
    <content type="html"><![CDATA[<p>本文学习了Java的内存区域、HotSpot虚拟机对象探秘和<code>OutOfMemoryError</code>异常。<br><a id="more"></a></p>
<h1 id="1-_运行时数据区域">1. 运行时数据区域</h1><p><img src="http://www.ddupfly.com/assets/2/1.jpg" alt=""></p>
<ol>
<li>程序计数器<br>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<br>由于Java虚拟机的多线程是通过线程切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对多核处理器是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，这类区域称为“线程私有”的内存。<br>如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法，计数器值为空（Undefined）。<br>此内存是唯一一个<strong>没有</strong>规定任何<code>OutOfMemoryError</code>情况的区域。</li>
<li>Java虚拟机栈<br>线程私有，生命周期与线程相同。<br>描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，为入栈到出栈的过程。<br>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象应用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。long和double占用2个，其余基本数据类型为1个局部变量空间。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变。<br>线程请求的栈深度大于虚拟机所允许的深度，抛出<code>StackOverflowError</code>异常；如果虚拟机动态扩展时无法申请到足够内存，抛出<code>OutOfMemoryError</code>异常。</li>
<li>本地方法栈<br>与虚拟机栈类似，区别为其为Native方法服务。<br>具体的虚拟机可以自由实现它，甚至Sun HotSpot虚拟机将其和虚拟机栈合二为一。<br>异常抛出同上。</li>
<li>Java堆<br>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。被所有线程共享，在虚拟机启动时创建，唯一目的就是存放对象实例，以及数组。<br>Java堆是垃圾收集器管理的主要区域，也可称为GC堆。从内存回收角度看，基于分代收集算法，Java堆细分为新生代和老年代，新生代包括Eden空间，From Survivor空间，To Survivor空间等。从内存分配角度看，线程共享的Java堆可能划分多个线程私有的分配缓冲区（TLAB）。<br>Java可以处于物理上不连续的内存空间，只要逻辑上是连续的即可，当前主流虚拟机可动态扩展（通过-Xmx和-Xms控制）。如果堆中内存不足，并且堆无法扩展，抛出<code>OutOfMemoryError</code>异常。</li>
<li>方法区<br>各个线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区为堆的一个逻辑部分，但称为Non-Heap（非堆），目的是与Java堆区分。<br>对于HotSpot，可把方法区分为永久代（Permanent Generation），因为GC分代收集扩展到方法区。但这样更容易遇到内存溢出问题，官方也有放弃永久代改用Native Memory来实现方法区的规划。在JDK1.7中，已经把原本放在永久代的字符串常量池移出至堆中。对此区域未完全回收将导致内存泄露。<br>当方法区无法满足内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</li>
<li>运行时常量池<br>它是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池。<br>运行时常量池具备动态性，在运行期间也可能将新的常量放入此中，例如String的intern()方法。<br>当常量池无法再申请到内存时抛出<code>OutOfMemoryError</code>异常。</li>
<li>直接内存<br>并不是虚拟机运行时数据区的一部分。在各个内存区域总和加上直接内存大于物理内存的限制，也可能抛出<code>OutOfMemoryError</code>异常。</li>
</ol>
<h1 id="2-_HotSpot虚拟机对象">2. HotSpot虚拟机对象</h1><ol>
<li>对象的创建<br>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先执行相应的类加载过程。<br>在类加载检查通过后，虚拟机为新生对象从Java堆中分配内存。对象所需内存的大小在类加载完成后便完全确定。<br>假设Java堆中内存是绝对规整的，所有用过的内存放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那分配内存就是挪动指针。这种分配方式称为<strong>“指针碰撞”</strong>。<br>假设Java堆中内存不是规整的，用过的与空闲的相互交错，虚拟机必须维护一个列表，记录哪些内存块可用。这种分配方式称为<strong>“空闲列表”</strong>。<br>选择哪种分配方式由Java堆是否规整决定，它由所采用的垃圾收集器是否带有压缩整理功能决定。在使用Serial、ParNew等带Compact过程的收集器是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器，采用空闲列表。并发情况下，这些过程并不是线程安全的。<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。<br>接下来，虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些存放在对象的对象头之中。<br>至此，以虚拟机的角度看，一个新的对象已经产生，但从Java程序的角度看，对象创建才刚刚开始，还须init初始化操作。</li>
<li>对象的内存布局<br>对象在内存的布局分为3块：对象头，实例数据和对齐填充。<br>对象头包括两部分信息，一是用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，成为Mark Word。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定是哪个类的实例。如果对象是Java数组，对象头中还须记录数组长度。<br>接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。<br>第三部分是对齐填充，起占位符的作用，HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。对象头正好为8字节的1倍或2倍。</li>
<li>对象的访问定位<br>栈上的reference数据来操作堆上的具体对象，对象的访问方式，取决于虚拟机实现。主流有2种。<br>如果用句柄访问。</li>
</ol>
<p><img src="http://www.ddupfly.com/assets/2/2.jpg" alt=""></p>
<p>如果使用字节指针访问</p>
<p><img src="http://www.ddupfly.com/assets/2/3.jpg" alt=""></p>
<p>各有优势，使用句柄最大好处是reference中存储的是稳定的句柄地址，在对象被移动时（垃圾收集移动对象）只会改变句柄中的实例数据指针，而reference本身不用改变。使用直接指针最大好处是速度更快，节省了一次指针定位的时间开销。Sun HotSpot采用第二种进行对象访问。</p>
<h1 id="3-_OutOfMemoryError异常">3. <code>OutOfMemoryError</code>异常</h1><ol>
<li>Java堆溢出<br>只要不断地创建对象，并且GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。<br>最小值参数-Xms，最大值参数-Xmx，设置为相等时可以避免自动扩展。<br>-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。<br>异常信息为：<code>java.lang.OutOfMemoryError: Java heap space</code>。<br>解决方法：如果是内存泄露，可以查看泄露对象到GC Roots的引用链，准确定位出泄露代码的位置。如果不存在泄露，应检查虚拟机堆参数大小是否可以调整，二是从代码上尝试减少程序运行期的内存消耗。</li>
<li>虚拟机栈和本地方法栈溢出<br>栈容量由-Xss参数设定。<br>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时，都是抛出<code>StackOverflowError</code>异常。多线程下，为每个线程的栈分配的内存越大，越容易产生内存溢出，抛出<code>OutOfMemoryError</code>异常。所以在不能减少线程数或更换64位虚拟机的情况下，应“减少内存”的手段解决。</li>
<li>方法区和运行时常量区溢出<br>JDK1.6及以前，由于常量池分配在永久代内，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小。<br>异常信息为：<code>java.lang.OutOfMemoryError: PermGen space</code>。<br>而JDK1.7后不会有这个结果。<br>方法区溢出也很常见，一个类要被垃圾收集器回收掉，绑定条件是比较苛刻的。例如大量JSP或动态产生JSP文件的应用，基于OSGi的应用，使用CGLib字节码增强和动态语言等。</li>
<li>本机直接内存溢出<br>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值一样。<br>OOM之后Dump文件很小，程序又直接或间接使用NIO，可能是本机直接内存溢出。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了Java的内存区域、HotSpot虚拟机对象探秘和<code>OutOfMemoryError</code>异常。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（1）]]></title>
    <link href="http://yoursite.com/2015/08/24/JVM-1/"/>
    <id>http://yoursite.com/2015/08/24/JVM-1/</id>
    <published>2015-08-24T08:27:00.000Z</published>
    <updated>2015-08-25T03:37:21.801Z</updated>
    <content type="html"><![CDATA[<p>本文学习了Java的技术体系和对Java技术的未来进行展望。<br><a id="more"></a></p>
<h1 id="1-_Java技术体系">1. Java技术体系</h1><ul>
<li>Sun官方定义的Java技术体系包括：Java程序设计语言，各种硬件平台上的Java虚拟机，Class文件格式，Java API类库，第三方Java类库。</li>
</ul>
<p><img src="http://www.ddupfly.com/assets/1/1.jpg" alt=""></p>
<ul>
<li>可以把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK(Java Development Kit)，是用于支持Java程序开发的最小环境。</li>
<li>可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE(Java Runtime Environment)，是支持Java程序运行的标准环境。</li>
</ul>
<h1 id="2-_展望Java技术的未来">2. 展望Java技术的未来</h1><ol>
<li>模块化<br>解决应用系统与技术平台越来越复杂、越来越庞大问题的重要途径。</li>
<li>混合语言<br>运行在一个虚拟机之上。通过特定领域的语言去解决特定领域的问题。</li>
<li>多核并行<br>如今，CPU硬件的发展方向已经从高频率转变为多核心。JDK1.5就引入了<code>java.util.concurrent</code>包实现了一个粗粒度的并发框架。JDK1.7加入的<code>java.util.concurrent.forkjoin</code>则是重要扩充。</li>
<li>进一步丰富语法<br>Java 5曾经对java语法了进行一次扩充，加入了自动装箱，泛型，动态注解，枚举，可变长参数，遍历循环等语法，使Java语言的精确性和易用性有了很大的进步。</li>
<li>64位虚拟机<br>虽然Java程序运行在64位虚拟机上需要付出比较大的额外代价（消耗更多的内存，运行速度落后），但企业级应用经常需要使用超过4GB内存，对64位虚拟机需求非常迫切。随着硬件的进一步发展，计算机终究会完全过渡到64位的时代，虚拟机对其的支持也应进一步完善。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了Java的技术体系和对Java技术的未来进行展望。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
</feed>
