<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[不要笑我的笨]]></title>
  <subtitle><![CDATA[梦想是一定要有的.. 万一实现了呢..]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-08-25T09:05:51.015Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Boom]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（3）]]></title>
    <link href="http://yoursite.com/2015/08/25/JVM-3/"/>
    <id>http://yoursite.com/2015/08/25/JVM-3/</id>
    <published>2015-08-25T06:42:20.000Z</published>
    <updated>2015-08-25T09:05:51.015Z</updated>
    <content type="html"><![CDATA[<p>本文学习了垃圾收集器与内存分配策略。<br><a id="more"></a></p>
<h1 id="1-_对象是否存活">1. 对象是否存活</h1><ol>
<li><p>引用计数算法<br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>客观地讲，引用计数算法的实现简单，判断效率也很高，例如微软的COM技术，Python语言等都使用了引用计数算法进行内存管理。<br>但是缺点是它很难解决对象之间相互循环引用的问题。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="type">MyObject</span> &#123;</span><br><span class="line">    public <span class="type">Object</span> <span class="keyword">ref</span> = null;</span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">MyObject</span> myObject1 = new <span class="type">MyObject</span>();</span><br><span class="line">        <span class="type">MyObject</span> myObject2 = new <span class="type">MyObject</span>();</span><br><span class="line">        myObject1.<span class="keyword">ref</span> = myObject2;</span><br><span class="line">        myObject2.<span class="keyword">ref</span> = myObject1;</span><br><span class="line">        myObject1 = null;</span><br><span class="line">        myObject2 = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是具体是为什么呢？当代码执行完line7时，两个对象的引用计数均为2。此时将myObject1和myObject2分别置为null，以前一个对象为例，它的引用计数将减1。若要满足垃圾回收的条件，需要清除myObject2中的ref这个引用，而要清除掉这个引用的前提条件是myObject2引用的对象被回收，可是该对象的引用计数也为1，因为myObject1.ref指向了它。以此类推，也就进入一种死循环的状态。</p>
</li>
<li>可达性分析算法<br>主流的商用程序语言（Java，C#等）的主流实现中，都是称通过可达性分析来判定对象是否存活的。<br>基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明该对象不可用。<br>在Java语言中，可作为GC Roots的对象包括下面几种：<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常用引用的对象。</li>
<li>本地方法栈中JNI（Native方法）引用的对象。</li>
</ul>
</li>
<li>四种引用类型<br>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用。强度依次逐渐减弱。<ul>
<li>强引用<br>是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用<br>是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li>
<li>弱引用<br>也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用<br>是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ul>
</li>
<li><p>生存还是死亡<br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这2种情况都视为“没有必要执行”。<br>如果对象被判定有必要执行finalize()方法，那么这个对象将会放置到一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里的“执行”是指虚拟机会触发方法，但并不承诺等待它运行结束。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果这时对象重新与引用链上的任何一对象建立关联，那么对象将存活下来；否则，对象基本上就真的被回收了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 1.对象可以在被GC时自我拯救</span><br><span class="line"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscape FC = <span class="keyword">null</span>;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>&#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"finalize method invoke"</span>);</span><br><span class="line">        FC = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception </span>&#123;</span><br><span class="line">        FC = <span class="keyword">new</span> FinalizeEscape();</span><br><span class="line">        FC = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(FC != <span class="keyword">null</span>)</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am alive"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am dead"</span>);</span><br><span class="line">        FC = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(FC != <span class="keyword">null</span>)</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am alive"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"i am dead"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">finalize method invoke </span><br><span class="line">i am alive </span><br><span class="line">i am dead</span><br></pre></td></tr></table></figure>
<p> 建议尽量避免使用finalize()，它运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</p>
</li>
<li>回收方法区<br>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。但判定一个类是否是“无用的类”的条件相对苛刻许多。<br>类需要同时满足下面3个条件才能算是“无用的类”。<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。<br>虚拟机<strong>可以</strong>对满足上述3个条件的无用类进行回收。<br>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</li>
</ul>
</li>
</ol>
<h1 id="2-_垃圾收集算法">2. 垃圾收集算法</h1><ol>
<li>标记-清除算法<br>Mark-Sweep算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</li>
</ol>
<p><img src="http://www.ddupfly.com/assets/3/1.jpg" alt=""></p>
<p>主要不足：一个是效率问题，两个过程都不高；二是空间问题，标记清除之后，将产生大量不连续的内存碎片，将来分配大内存，无连续空间的时候，不得不提前触发一次垃圾收集动作。</p>
<ol>
<li>复制算法<br>Copying算法，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存，实现简单，运行高效。只是缩小一半内存，算法的代价有点高了。</li>
</ol>
<p><img src="http://www.ddupfly.com/assets/3/2.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了垃圾收集器与内存分配策略。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（2）]]></title>
    <link href="http://yoursite.com/2015/08/25/JVM-2/"/>
    <id>http://yoursite.com/2015/08/25/JVM-2/</id>
    <published>2015-08-25T02:15:34.000Z</published>
    <updated>2015-08-25T06:39:04.736Z</updated>
    <content type="html"><![CDATA[<p>本文学习了Java的内存区域、HotSpot虚拟机对象探秘和<code>OutOfMemoryError</code>异常。<br><a id="more"></a></p>
<h1 id="1-_运行时数据区域">1. 运行时数据区域</h1><p><img src="http://www.ddupfly.com/assets/2/1.jpg" alt=""></p>
<ol>
<li>程序计数器<br>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<br>由于Java虚拟机的多线程是通过线程切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对多核处理器是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，这类区域称为“线程私有”的内存。<br>如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法，计数器值为空（Undefined）。<br>此内存是唯一一个<strong>没有</strong>规定任何<code>OutOfMemoryError</code>情况的区域。</li>
<li>Java虚拟机栈<br>线程私有，生命周期与线程相同。<br>描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，为入栈到出栈的过程。<br>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象应用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。long和double占用2个，其余基本数据类型为1个局部变量空间。局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变。<br>线程请求的栈深度大于虚拟机所允许的深度，抛出<code>StackOverflowError</code>异常；如果虚拟机动态扩展时无法申请到足够内存，抛出<code>OutOfMemoryError</code>异常。</li>
<li>本地方法栈<br>与虚拟机栈类似，区别为其为Native方法服务。<br>具体的虚拟机可以自由实现它，甚至Sun HotSpot虚拟机将其和虚拟机栈合二为一。<br>异常抛出同上。</li>
<li>Java堆<br>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。被所有线程共享，在虚拟机启动时创建，唯一目的就是存放对象实例，以及数组。<br>Java堆是垃圾收集器管理的主要区域，也可称为GC堆。从内存回收角度看，基于分代收集算法，Java堆细分为新生代和老年代，新生代包括Eden空间，From Survivor空间，To Survivor空间等。从内存分配角度看，线程共享的Java堆可能划分多个线程私有的分配缓冲区（TLAB）。<br>Java可以处于物理上不连续的内存空间，只要逻辑上是连续的即可，当前主流虚拟机可动态扩展（通过-Xmx和-Xms控制）。如果堆中内存不足，并且堆无法扩展，抛出<code>OutOfMemoryError</code>异常。</li>
<li>方法区<br>各个线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区为堆的一个逻辑部分，但称为Non-Heap（非堆），目的是与Java堆区分。<br>对于HotSpot，可把方法区分为永久代（Permanent Generation），因为GC分代收集扩展到方法区。但这样更容易遇到内存溢出问题，官方也有放弃永久代改用Native Memory来实现方法区的规划。在JDK1.7中，已经把原本放在永久代的字符串常量池移出至堆中。对此区域未完全回收将导致内存泄露。<br>当方法区无法满足内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</li>
<li>运行时常量池<br>它是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后，存放到方法区的运行时常量池。<br>运行时常量池具备动态性，在运行期间也可能将新的常量放入此中，例如String的intern()方法。<br>当常量池无法再申请到内存时抛出<code>OutOfMemoryError</code>异常。</li>
<li>直接内存<br>并不是虚拟机运行时数据区的一部分。在各个内存区域总和加上直接内存大于物理内存的限制，也可能抛出<code>OutOfMemoryError</code>异常。</li>
</ol>
<h1 id="2-_HotSpot虚拟机对象">2. HotSpot虚拟机对象</h1><ol>
<li>对象的创建<br>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先执行相应的类加载过程。<br>在类加载检查通过后，虚拟机为新生对象从Java堆中分配内存。对象所需内存的大小在类加载完成后便完全确定。<br>假设Java堆中内存是绝对规整的，所有用过的内存放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那分配内存就是挪动指针。这种分配方式称为<strong>“指针碰撞”</strong>。<br>假设Java堆中内存不是规整的，用过的与空闲的相互交错，虚拟机必须维护一个列表，记录哪些内存块可用。这种分配方式称为<strong>“空闲列表”</strong>。<br>选择哪种分配方式由Java堆是否规整决定，它由所采用的垃圾收集器是否带有压缩整理功能决定。在使用Serial、ParNew等带Compact过程的收集器是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器，采用空闲列表。并发情况下，这些过程并不是线程安全的。<br>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。<br>接下来，虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些存放在对象的对象头之中。<br>至此，以虚拟机的角度看，一个新的对象已经产生，但从Java程序的角度看，对象创建才刚刚开始，还须init初始化操作。</li>
<li>对象的内存布局<br>对象在内存的布局分为3块：对象头，实例数据和对齐填充。<br>对象头包括两部分信息，一是用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，成为Mark Word。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定是哪个类的实例。如果对象是Java数组，对象头中还须记录数组长度。<br>接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。<br>第三部分是对齐填充，起占位符的作用，HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。对象头正好为8字节的1倍或2倍。</li>
<li>对象的访问定位<br>栈上的reference数据来操作堆上的具体对象，对象的访问方式，取决于虚拟机实现。主流有2种。<br>如果用句柄访问。</li>
</ol>
<p><img src="http://www.ddupfly.com/assets/2/2.jpg" alt=""></p>
<p>如果使用字节指针访问</p>
<p><img src="http://www.ddupfly.com/assets/2/3.jpg" alt=""></p>
<p>各有优势，使用句柄最大好处是reference中存储的是稳定的句柄地址，在对象被移动时（垃圾收集移动对象）只会改变句柄中的实例数据指针，而reference本身不用改变。使用直接指针最大好处是速度更快，节省了一次指针定位的时间开销。Sun HotSpot采用第二种进行对象访问。</p>
<h1 id="3-_OutOfMemoryError异常">3. <code>OutOfMemoryError</code>异常</h1><ol>
<li>Java堆溢出<br>只要不断地创建对象，并且GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。<br>最小值参数-Xms，最大值参数-Xmx，设置为相等时可以避免自动扩展。<br>-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。<br>异常信息为：<code>java.lang.OutOfMemoryError: Java heap space</code>。<br>解决方法：如果是内存泄露，可以查看泄露对象到GC Roots的引用链，准确定位出泄露代码的位置。如果不存在泄露，应检查虚拟机堆参数大小是否可以调整，二是从代码上尝试减少程序运行期的内存消耗。</li>
<li>虚拟机栈和本地方法栈溢出<br>栈容量由-Xss参数设定。<br>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时，都是抛出<code>StackOverflowError</code>异常。多线程下，为每个线程的栈分配的内存越大，越容易产生内存溢出，抛出<code>OutOfMemoryError</code>异常。所以在不能减少线程数或更换64位虚拟机的情况下，应“减少内存”的手段解决。</li>
<li>方法区和运行时常量区溢出<br>JDK1.6及以前，由于常量池分配在永久代内，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小。<br>异常信息为：<code>java.lang.OutOfMemoryError: PermGen space</code>。<br>而JDK1.7后不会有这个结果。<br>方法区溢出也很常见，一个类要被垃圾收集器回收掉，绑定条件是比较苛刻的。例如大量JSP或动态产生JSP文件的应用，基于OSGi的应用，使用CGLib字节码增强和动态语言等。</li>
<li>本机直接内存溢出<br>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值一样。<br>OOM之后Dump文件很小，程序又直接或间接使用NIO，可能是本机直接内存溢出。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了Java的内存区域、HotSpot虚拟机对象探秘和<code>OutOfMemoryError</code>异常。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》学习笔记（1）]]></title>
    <link href="http://yoursite.com/2015/08/24/JVM-1/"/>
    <id>http://yoursite.com/2015/08/24/JVM-1/</id>
    <published>2015-08-24T08:27:00.000Z</published>
    <updated>2015-08-25T03:37:21.801Z</updated>
    <content type="html"><![CDATA[<p>本文学习了Java的技术体系和对Java技术的未来进行展望。<br><a id="more"></a></p>
<h1 id="1-_Java技术体系">1. Java技术体系</h1><ul>
<li>Sun官方定义的Java技术体系包括：Java程序设计语言，各种硬件平台上的Java虚拟机，Class文件格式，Java API类库，第三方Java类库。</li>
</ul>
<p><img src="http://www.ddupfly.com/assets/1/1.jpg" alt=""></p>
<ul>
<li>可以把Java程序设计语言、Java虚拟机、Java API类库这三部分统称为JDK(Java Development Kit)，是用于支持Java程序开发的最小环境。</li>
<li>可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE(Java Runtime Environment)，是支持Java程序运行的标准环境。</li>
</ul>
<h1 id="2-_展望Java技术的未来">2. 展望Java技术的未来</h1><ol>
<li>模块化<br>解决应用系统与技术平台越来越复杂、越来越庞大问题的重要途径。</li>
<li>混合语言<br>运行在一个虚拟机之上。通过特定领域的语言去解决特定领域的问题。</li>
<li>多核并行<br>如今，CPU硬件的发展方向已经从高频率转变为多核心。JDK1.5就引入了<code>java.util.concurrent</code>包实现了一个粗粒度的并发框架。JDK1.7加入的<code>java.util.concurrent.forkjoin</code>则是重要扩充。</li>
<li>进一步丰富语法<br>Java 5曾经对java语法了进行一次扩充，加入了自动装箱，泛型，动态注解，枚举，可变长参数，遍历循环等语法，使Java语言的精确性和易用性有了很大的进步。</li>
<li>64位虚拟机<br>虽然Java程序运行在64位虚拟机上需要付出比较大的额外代价（消耗更多的内存，运行速度落后），但企业级应用经常需要使用超过4GB内存，对64位虚拟机需求非常迫切。随着硬件的进一步发展，计算机终究会完全过渡到64位的时代，虚拟机对其的支持也应进一步完善。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文学习了Java的技术体系和对Java技术的未来进行展望。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="《深入理解Java虚拟机》" scheme="http://yoursite.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
  </entry>
  
</feed>
